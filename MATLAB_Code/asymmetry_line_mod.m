function [MS,varargout] = asymmetry_line_mod(D,ValueGRID,ixGRID,type)
% 
% ASYMMETRY   directional asymmetry of divide segments with line output
%
% Syntax
%
%     [MS] = asymmetry(D,ValueGRID, ixGRID, type)
%     [MS,S] = asymmetry(D,ValueGRID, ixGRID, type)
%
% Description
%
%     ASYMMETRY computes for each segment in the divide network the mean or
%     median asymmetry of a value represented as a raster of divide
%     adjacent pixels. This function has been modified from the original TT
%     function and outputs both, the original asymmetry direction and
%     magnitude (rho, theta) and the modified direction and magnitude
%     (m_dn, m_theta).
%     The original divide asymmetry is represented as a vector that is 
%     centered on the divide segment and points in the direction of lower 
%     values. It is computed by adding the direction and magnitude of value
%     differences from divide adjacent pixels. This vector addition can
%     lead to asymmetry vectors that are far from perpendicular to the
%     divide direction.
%     To keep divide asymmetry vector always perpendicular to the divide,
%     we modified the orignal function. In this version the average strike
%     of the divide is computed. Subsequently, ValueGRID values on either
%     side of the divide are averaged and the difference is taken and
%     normalized to a DAI. The direction of the asymmetry is then assumed
%     to be perpendicular to the strike of the divide and pointing towards
%     the basin with lower values. 
%     In the modified approach a grid of basin labels (ixGRID) is used to
%     only compute asymmetry for 2 opposing basins. This was introduced
%     because some divide segments drain to more than 2 basins. A warning
%     will notify the user if that is the case, and will remove, usually
%     tiny, extra basins.
%     Note that the optional output 'S' contains values for all divide
%     nodes, as well as divide-segment averaged values distributed to all
%     divide nodes. It lends itself for diplaying using the function
%     'plotc'.
%
% Input
%
%     D         instance of class DIVIDEobj
%     ValueGRID instance of class GRIDobj
%     ixGRID    instance of class GRIDobj lablling divide pixels based on
%               drainage basins as generated by 'bconfgrid' function
%     type      'mean' or 'median' based on which method should be used for
%               pixel averaging on either divide side
%
% Output
%
%     MS        mapping structure with POINT entries representing 
%               divide segments
%      .Geometry  - 'Point'
%      .X         - x coordinate 
%      .Y         - y coordinate 
%      .order     - order
%      .dist      - along-divide distance 
%      .u         - x-component of asymmetry (east is positive)
%      .v         - y-component of asymmetry (north is positive)
%      .theta     - angle from north of asymmetry direction
%      .rho       - magnitude of asymmetry
%      .m_dn      - magnitude of asymmetry (modified)
%      .m_theta   - direction of asymmetry (modified)
%
% Optional output     
%     
%     S         data structure with LINE entries representing divide
%               segments
%      .IX        - linear indices of divide segment nodes
%      .x         - x coordinate of divide nodes
%      .y         - y coordinate of divide nodes
%      .order     - order
%      .dist      - along-divide distance 
%      .u         - x-component of divide node asymmetry (east is positive)
%      .v         - y-component of divide node asymmetry (north is positive)
%      .theta     - angle from north of divide segment(!) asymmetry 
%      .rho       - magnitude of divide segment(!) asymmetry 
%      .m_dn      - magnitude of asymmetry (modified)
%      .m_theta   - direction of asymmetry (modified)
%
% Example
%     
%     DEM = GRIDobj('srtm_bigtujunga30m_utm11.tif');
%     FD  = FLOWobj(DEM,'preprocess','c');
%     S = STREAMobj(FD,flowacc(FD)>1000);
%     D = DIVIDEobj(FD,S);
%     D = divorder(D,'topo');
%     DZ = vertdistance2stream(FD,S,DEM);
%     [MS,S] = asymmetry(D,DZ);
%     for i = 1 : length(S)
%         S(i).length = max(getdistance(S(i).x,S(i).y));
%     end
%     imageschs(DEM,[],'colormap',[.9 .9 .9],'colorbar',false);
%     %imageschs(DEM,gradient8(DEM,'deg'),'caxis',[0 45]) % with slope as background
%     hold on
%     plotc(D,vertcat(S.rho),'caxis',[0 0.5],'limit',[1000 inf])
%     colormap(gca,flipud(pink))
%     axis image
%     hc = colorbar;
%     hc.Label.String = 'Divide asymmetry index';
%     hold on
%     ix = [MS.dist]>1000; % & [MS.rho]>0;
%     f = [S.length]./1e3;
%     quiver([MS(ix).X],[MS(ix).Y],[MS(ix).u].*f(ix),[MS(ix).v].*f(ix),2,...
%         'color','r','linewidth',1)
%     title('Drainage divide asymmetry and direction of lower hillslope relief')
%
%
% See also: DIVIDEobj, DIVIDEobj/sort
%
% Orignal script by: Dirk Scherler (scherler[at]gfz-potsdam.de), Nov 2018
% Modified by: Richard Ott (r.f.ott@uva.nl), Nov 2022

% Get vectors 
[x,y] = ind2coord(D,vertcat(D.IX));

% Preprocess DZ grid
ValueGRID.Z(ValueGRID.Z<0) = 0;
ValueGRID.Z(isinf(ValueGRID.Z)) = nan;

% Calculate across divide attributes 
x1 = [NaN; x(1:end-1)];
x2 = [NaN; x(2:end)];
y1 = [NaN; y(1:end-1)];
y2 = [NaN; y(2:end)];
dx = x1-x2;             % calculate x-difference between pixels along divide
dy = y1-y2;             % calculate y-difference between pixels along divide
hcs = ValueGRID.cellsize/2;  % half cell size
ix = dx==0;             % vertical link
iy = dy==0;             % horizontal link
meanx = (x1+x2)./2;
meany = (y1+y2)./2;     
px = meanx + hcs.*ix;
qx = meanx - hcs.*ix; 
py = meany + hcs.*iy;
qy = meany - hcs.*iy;
pix = coord2ind(ValueGRID,px,py); % top and right, IX of divide adjacent pixel
qix = coord2ind(ValueGRID,qx,qy); % bottom and left, IX of divide adjacent pixel
nx = ~isnan(pix) & ~isnan(qix);  % number of divide pixel pairs

% get basin IDs for all drainage divide pixels ---------------------------
pID = nan(size(pix)); qID = nan(size(qix));
pID(~isnan(pix)) = ixGRID.Z(pix(~isnan(pix)));
qID(~isnan(qix)) = ixGRID.Z(qix(~isnan(qix)));
% -------------------------------------------------------------------------

% direction of asymmetry (orthogonal to the orientation)
u = ix;
v = iy;

% magnitude of asymmetry
hr1 = nan(size(pix));
hr2 = hr1;
hr1(nx) = ValueGRID.Z(pix(nx)); % top and right
hr2(nx) = ValueGRID.Z(qix(nx)); % bottom and left
dhr = diff([hr1,hr2],1,2); % top minus bottom, right minus left
dhrn = dhr./sum([hr1,hr2],2); % 
u = u.*dhrn;
v = v.*dhrn;
% -------------------------------------------------------------------------
S = onl2struct(D.IX,'x',x,'y',y,'order',D.order,'dist',D.distance,...
    'u',u,'v',v,'pix',pix,'qix',qix,'pID',pID,'qID',qID);
% -------------------------------------------------------------------------
n = numel(S);

MS = struct('Geometry','Line',...
    'X',cell(n,1),...
    'Y',cell(n,1));

warning_counter = 0;
error_counter = 0;

for i = 1 : length(MS)
    
    tx = S(i).x(1:end-1);
    ty = S(i).y(1:end-1);
    td = getdistance(tx,ty);
    if numel(td)>1
        MS(i).X = tx;
        MS(i).Y = ty;
    else
        MS(i).X = tx;
        MS(i).Y = ty;
    end
    MS(i).order = nanmean(S(i).order);
    MS(i).dist = nanmean(S(i).dist);
    MS(i).u = double(nanmean(S(i).u));
    MS(i).v = double(nanmean(S(i).v));
    
    [theta,rho] = cart2pol(MS(i).u,MS(i).v);
    theta = rad2deg(theta);
    theta = -theta+90;
    theta(theta<0) = theta(theta<0)+360;
    MS(i).theta = double(theta);
    MS(i).rho = double(rho);
    
    % ---------------------------------------------------------------------
    % calculate mean/median difference between divide sides
    inds = [S(i).pID; S(i).qID];  % get basin ID's of this divide segment
    Binds = unique(inds); % get unique values of bconfluences that divide drains to
    Binds(isnan(Binds)) = []; % remove nans
    % here's a quick check to make sure the method works and divides never
    % drain to more than two confluences
 
      if length(Binds) > 2
        disp(i)
        warning('your divide drains has more than two bconfluences'); 
        warning_counter = warning_counter +1;
        while length(Binds)>2
            bin_length = nan(1,length(Binds));
            for j =1:length(Binds)
                bin_length(j)= length(find(inds==Binds(j)));
            end
            [min_value,min_index]=min(bin_length);
            if min_value >= 20
                warning('!!! A large divide segment has more than two bconfluences! Check for DAI values of 9999')
                error_counter = error_counter +1;
                MS(i).m_theta = nan;
                MS(i).m_dn    = 9999;
                Binds = [0,0];
            else
                Binds(min_index)=[];
                clear bin_length
            end
        end
        
        if min_value >= 20
            continue
        end
    end
    
    if length(Binds) == 2 % some basins do not have 2 labelled divides ( basins near edge of DEM)
        % simply move on and not calculate asymmetry for those
    
        ix_all = [S(i).pix; S(i).qix];  % get IX of all divide adjacent pixels
        side1 = unique(ix_all(inds == Binds(1))); % get IX of all pixels draining to same side
        side2 = unique(ix_all(inds == Binds(2))); % other side, use unique to avoid double counting some pixels

        if strcmpi(type,'mean')
            m1 = nanmean(ValueGRID.Z(side1));  % top and right
            m2 = nanmean(ValueGRID.Z(side2));  % bottom and left
        elseif strcmpi(type,'median')
            m1 = nanmedian(ValueGRID.Z(side1));% top and right
            m2 = nanmedian(ValueGRID.Z(side2)); % bottom and left
        else
            error("Supply valid input for type ('mean','median')")
        end
        m_dhr = m2 - m1;  % difference mean/median left and right
        m_dhrn = abs(m_dhr /(m1 + m2)); % normalize
        % data repair, assign zero value if something is nan
        if or(isnan(m_dhrn),isinf(m_dhrn))
            m_dhrn = 0;
        end
        MS(i).m_dn = double(m_dhrn);  % assign to divide

    %     % calculate average direction of divide segment by taking direction of
    %     % connection line between first and last segment of divide segment
        [div_theta,~] = cart2pol(tx(end)-tx(1), ty(end)-ty(1));
        div_theta = rad2deg(div_theta);
        div_theta = -div_theta+90; 
        div_theta(div_theta<0) = div_theta(div_theta<0)+360;


        % Calculate average direction of drainage divide by axveraging x,y
        % coords on either side of divide 
        [side1_x,side1_y] = ind2coord(ValueGRID,side1);  % get coords of side 1
        [side2_x,side2_y] = ind2coord(ValueGRID,side2); % get coords of side 2
        side1_xm = nanmean(side1_x); % mean x coord of side 1
        side1_ym = nanmean(side1_y);
        side2_xm = nanmean(side2_x);
        side2_ym = nanmean(side2_y);
        x_conn = side2_xm - side1_xm; % x coordinate of connection vector for average x,y of both sides
        y_conn = side2_ym - side1_ym;

        % calculate azmiuth of vector between average x,y of both divide sides
        [conn_theta,~] = cart2pol(x_conn, y_conn); 
        conn_theta = rad2deg(conn_theta);
        conn_theta = -conn_theta+90; 
        conn_theta(conn_theta<0) = conn_theta(conn_theta<0)+360;

        if m_dhr > 0 % side 1 has a higher raster value (is steeper etc)
            if conn_theta > 180 % turn connection vactor around if side 1 was larger, because it's poitning towards side 2
                conn_theta = conn_theta - 180;
            else
                conn_theta = conn_theta + 180;
            end
        end

        % find vectors perpendicular to divide segment endpoint connection
        % vector
        div_theta_perp1 = div_theta - 90;
        div_theta_perp2 = div_theta + 90;
        % correct anglues for below 0 and above 360 values
        if div_theta_perp1 < 0 
            div_theta_perp1 = div_theta_perp1 + 360;
        elseif div_theta_perp1 > 360 
            div_theta_perp1 = div_theta_perp1 - 360;
        end
        if div_theta_perp2 < 0 
            div_theta_perp2 = div_theta_perp2 + 360;
        elseif div_theta_perp2 > 360 
            div_theta_perp2 = div_theta_perp2 - 360;
        end

        % see which of the two directions the connection vector comes closest
        % to
        angle1 = abs(mod((conn_theta+180), 360) - mod((div_theta_perp1+180), 360)); % angle between conn_theta and div_theta_perp1
        angle2 = abs(mod((conn_theta+180), 360) - mod((div_theta_perp2+180), 360));
        
        if angle1 < angle2
            value_div_perp_direction = div_theta_perp1;
        else
            value_div_perp_direction = div_theta_perp2;
        end

        MS(i).m_theta = double(value_div_perp_direction);
    else
        MS(i).m_theta = nan;
        MS(i).m_dn    = nan;
    end
    % ---------------------------------------------------------------------
    
    S(i).theta = [ones(size(tx)).*double(theta);nan];
    S(i).rho = [ones(size(tx)).*double(rho);nan];
    S(i).east = [ones(size(tx)).*double(MS(i).u);nan];
    S(i).north = [ones(size(tx)).*double(MS(i).v);nan];
    S(i).m_dn = [ones(size(tx)).*double(MS(i).m_dn);nan];
    S(i).m_theta = [ones(size(tx)).*double(MS(i).theta);nan];

end

disp(['Warning: number of all divides with >2 b-confluences:' num2str(warning_counter)])
disp(['Error: number of large divides with >2 b-confluences (check for DAI value 9999):' num2str(error_counter)])

if nargout>1
    varargout{1} = S;
end

